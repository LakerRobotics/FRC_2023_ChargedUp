// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.DriveTrainConstants;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.interfaces.Gyro;



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax cANSparkMAXleft1;
private CANSparkMax cANSparkMAXleft2;
private MotorControllerGroup driveTrainGroupLeft;
private CANSparkMax cANSparkMAXright1;
private CANSparkMax cANSparkMAXright2;
private MotorControllerGroup driveTrainGroupRight;
private DifferentialDrive differentialDrive1;
private RelativeEncoder m_encoderLeft;
private RelativeEncoder m_encoderRight;
private ADXRS450_Gyro m_Gyro;
private final DifferentialDriveOdometry m_odometry;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */
    public DriveTrain() {
    m_Gyro = new ADXRS450_Gyro(); 

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
cANSparkMAXleft1 = new CANSparkMax(19, MotorType.kBrushless);
cANSparkMAXleft1.setInverted(true); 
 
cANSparkMAXleft2 = new CANSparkMax(16, MotorType.kBrushless);
cANSparkMAXleft2.setInverted(true); 
 
 

/**driveTrainLeft = new PWMSparkMax(0);
 addChild("DriveTrainLeft",driveTrainLeft);
 driveTrainLeft.setInverted(true);

driveTrainLeft2 = new PWMSparkMax(2);
 addChild("DriveTrainLeft2",driveTrainLeft2);
 driveTrainLeft2.setInverted(true);
*/
driveTrainGroupLeft = new MotorControllerGroup(cANSparkMAXleft1, cANSparkMAXleft2);
 addChild("DriveTrainGroupLeft",driveTrainGroupLeft);
 

cANSparkMAXright1 = new CANSparkMax(20, MotorType.kBrushless);
cANSparkMAXright2 = new CANSparkMax(1, MotorType.kBrushless);
 



/*driveTrainRight = new PWMSparkMax(1);
 addChild("DriveTrainRight",driveTrainRight);
 driveTrainRight.setInverted(false);

driveTrainRight2 = new PWMSparkMax(3);
 addChild("DriveTrainRight2",driveTrainRight2);
 driveTrainRight2.setInverted(false);
*/
driveTrainGroupRight = new MotorControllerGroup(cANSparkMAXright1, cANSparkMAXright2);
 addChild("DriveTrainGroupRight",driveTrainGroupRight);
 
// 
differentialDrive1 = new DifferentialDrive (driveTrainGroupRight, driveTrainGroupLeft);// note left and right in wrong order so the robot responds correctly (turning left when joystick is pushed left)
 addChild("Differential Drive 1",differentialDrive1);

// differentialDrive1.
// differentialDrive1.setSafetyEnabled(true);
//differentialDrive1.setExpiration(0.1);
//differentialDrive1.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    // Encoder object created to display position values
    m_encoderLeft  = cANSparkMAXleft1.getEncoder();
    // position by default provides nmber of rotations, gearboxratio is 10.7
    double gearBoxRatio = 10.7;
    double wheelDiameter = 6; // 6 inches
    double wheelCircumference = wheelDiameter * java.lang.Math.PI;
    double convertOneMotorRotationToInches = wheelCircumference/gearBoxRatio;
    //m_encoderLeft.setPositionConversionFactor(convertOneMotorRotationToInches);
    m_encoderLeft.setVelocityConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor);
m_encoderLeft.setVelocityConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor/60);

    //Encoder starts in RPM, we need to get to inches/sec
    double convertMinToSeconds = 60;//converts RPM (Rev/min) to Rev/sec
    double convertOneRPMtoInPerSec = convertOneMotorRotationToInches/convertMinToSeconds;
    m_encoderLeft.setVelocityConversionFactor(convertOneRPMtoInPerSec);

    m_encoderRight = cANSparkMAXright1.getEncoder();
    //m_encoderRight.setPositionConversionFactor(convertOneMotorRotationToInches);
    m_encoderRight.setPositionConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor);
    m_encoderRight.setVelocityConversionFactor(DriveTrainConstants.kLinearDistanceConversionFactor/60);
   // m_encoderRight.setVelocityConversionFactor(convertOneRPMtoInPerSec);
   
   m_Gyro.reset();
   m_Gyro.calibrate();
   resetEncoders();

 m_odometry = new DifferentialDriveOdometry(m_Gyro.getRotation2d(),0,0);
 m_odometry.resetPosition(m_Gyro.getRotation2d(), m_encoderLeft.getPosition(), m_encoderRight.getPosition(), new Pose2d());


    //NOTE IF CONVERSION SETTINGS NOT WORKING, Remove this if they do work.
    //2021 Cheif Delphi commentary say to get conversionfactor  to work need to burn settings:
    // from:https://www.chiefdelphi.com/t/spark-max-encoder-setpositionconversionfactor-not-doing-anything/396629/17
    // Burn settings into Spark MAX flash
    //leftMotor1.burnFlash();
    }
    
    public void resetEncoders(){
     m_encoderRight.setPosition(0);
     m_encoderLeft.setPosition(0);
}

    public void setBreakMode(){
        cANSparkMAXleft1.setIdleMode(IdleMode.kBrake);
        cANSparkMAXleft2.setIdleMode(IdleMode.kBrake);
        cANSparkMAXright1.setIdleMode(IdleMode.kBrake);
        cANSparkMAXright2.setIdleMode(IdleMode.kBrake);
    } 

    public void setCoastMode() {
    cANSparkMAXleft1.setIdleMode(IdleMode.kCoast);
    cANSparkMAXleft2.setIdleMode(IdleMode.kCoast);
    cANSparkMAXright1.setIdleMode(IdleMode.kCoast);
    cANSparkMAXright2.setIdleMode(IdleMode.kCoast);
    }

    public double getRightEncoderPosition(){
        return m_encoderRight.getPosition();
    }

public double getRightEncoderVelocity(){
    return m_encoderRight.getVelocity();
}

    public double getLeftEncoderPosition(){
        return m_encoderLeft.getPosition();
    }

    public double getLeftEncoderVelocity(){
        return m_encoderLeft.getVelocity();
    }

    public double getHeading(){
        return m_Gyro.getRotation2d().getDegrees();
    }
    public double getTurnRate(){
        return -m_Gyro.getRate();
    }

    public Pose2d getPose(){
        return m_odometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose){
        resetEncoders();
        m_odometry.resetPosition(m_Gyro.getRotation2d(), m_encoderLeft.getPosition(), m_encoderRight.getPosition(), pose);
    }

    public DifferentialDriveWheelSpeeds getWheelSpeeds(){
        return new DifferentialDriveWheelSpeeds(getLeftEncoderVelocity(), getRightEncoderVelocity());
    }

    public void tankDriveVolts(double leftVolts, double rightVolts){
        driveTrainGroupLeft.setVoltage(leftVolts); 
        driveTrainGroupRight.setVoltage(rightVolts);
        DifferentialDrive.feed();
    }

    public double getAverageEncoderDistance(){
        return (getLeftEncoderPosition()+getRightEncoderPosition());
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        m_odometry.update(m_Gyro.getRotation2d(), m_encoderLeft.getPosition(), m_encoderRight.getPosition());

        SmartDashboard.putNumber("Left encoder value meters", getLeftEncoderPosition());
        SmartDashboard.putNumber("Right encoder value meters", getRightEncoderPosition());
        SmartDashboard.putNumber("Gyro heading", getHeading());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void arcadeDrive(double power, double turnpower) {
        boolean squareInputsToReduceSenstivityAtLowSpeeds = true;
        differentialDrive1.arcadeDrive(power, turnpower, squareInputsToReduceSenstivityAtLowSpeeds);
    }
    public void tankDrive(double leftPower, double rightPower){
        differentialDrive1.tankDrive(leftPower, rightPower);
    }

    public RelativeEncoder getEncoderLeft(){
        return m_encoderLeft;
    };
    public RelativeEncoder getEncoderRight(){
        return m_encoderRight;
    };

    public Gyro getGyro(){
        return m_Gyro;
    }

}

