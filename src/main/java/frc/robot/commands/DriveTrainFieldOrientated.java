package frc.robot.commands;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.DriveTrain;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelHelper;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelMotionControlHelper;
import frc.robot.subsystems.utilities.EncoderAvgLeftRight;
import frc.robot.subsystems.utilities.MotionControlPIDController;
import frc.robot.subsystems.utilities.PIDOutputStraightMotion;

/**
 *
 */
public class DriveTrainFieldOrientated extends CommandBase {
    private final DriveTrain m_DriveTrain;

    RelativeEncoder m_leftEncoder; 
    RelativeEncoder m_rightEncoder; 
    Gyro m_rotationSource;

    protected EncoderAvgLeftRight m_LineSource;
	protected Gyro m_TurnSource;
    private double m_distance;
    private double m_DistanceToExceed; //TODO Check if can Eliminate this redudent variable
    private double m_maxspeed;
    private double m_ramp;
    private double m_targetAngle;
    
	private double m_StraightTolerance;
	private AdjustSpeedAsTravelHelper m_AdustsSpeedAsTravelStraightHelper;
    private PIDOutputStraightMotion    m_StraightRotationPIDOutput;
	private MotionControlPIDController m_StraightDistancePIDController;

    private SimpleMotorFeedforward m_simpleMotorFeedForward;

    private boolean isStraightMovingForward = true;
    public final double StraightKp = 0.006;// 0.020;
    public final double StraightKi = 0.008;//0.001;
    public final double StraightKd = 0.0;
//    private final double StraightMaxPower = 1;

/** 
    * @param theDriveTrain the drivetrain subsystem
    * @param distanceSource the wheel encoders
    * @param rotationSource the Gryro
    * @param distance  to travel in inches
    * @param maxSpeed  in ft/sec
    * @param ramp      in inches
    * @param targetAngle assume it want Degrees
    ------------------------------------------------*/
   public DriveTrainFieldOrientated(DriveTrain theDriveTrain){

        m_DriveTrain = theDriveTrain;
        addRequirements(m_DriveTrain);
        m_leftEncoder    = theDriveTrain.getEncoderLeft();
        m_rightEncoder   = theDriveTrain.getEncoderRight();
        m_rotationSource = theDriveTrain.getGyro();
     
        m_LineSource = new EncoderAvgLeftRight(m_leftEncoder, m_rightEncoder);
        m_TurnSource = m_rotationSource;
        m_maxspeed = maxspeed;
        m_targetAngle = targetAngle;

        m_StraightTolerance = 2;



    }
     
/**
 * 
 * @param currentDistance, 
 * @return the target Angle in degree for the provided distance, note in the base drive straight this is always just the passed in straight angle
 *         but in a derived class like turn on a circle it would but updated for each distance
 */
    protected double getTargetAngle(double currentDistance){
        return m_targetAngle;
    };



    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
	{
        angleStick = new Joystick(0);
        powerStick = new Joystick(1);
        gyro = new ADXRS450_Gyro();
        anglePIDController = new PIDController(0.05, 0, 0);
        speedPIDController = new PIDController(0.1, 0, 0);

		double convertedSpeed = m_maxspeed * 12; 	// Converted from Feet/Second to Inches/Second
			
//		}
    }
}

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {

            RobotContainer.getInstance().getDriverController().getLeftY() /*power*/,
            RobotContainer.getInstance().getDriverController().getRightX() /*turnpower*/
        double desiredAngle = getJoystickAngle();
        double desiredSpeed = powerStick.getY() * 12; // convert joystick value to ft/sec

        SmartDashboard.putNumber("Desired Angle", desiredAngle);
        SmartDashboard.putNumber("Desired Speed", desiredSpeed);

        drive(desiredAngle, desiredSpeed);
        SmartDashboard.putNumber("DriveStraight turnPower", turnPower);
    }

    private void drive(double desiredAngle, double desiredSpeed) {
        double currentAngle = gyro.getAngle();
        double currentSpeed = getSpeed();
        double turn = anglePIDController.calculate(currentAngle, desiredAngle) + desiredAngle * 0.05;
        double speed = speedPIDController.calculate(currentSpeed, desiredSpeed) + desiredSpeed * 0.05;
    
        // Drive the robot based on the desired angle and speed
        driveTrain.arcadeDrive(speed, turn);
      }


    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }

    private double getJoystickAngle() {
        double x = angleStick.getX();
        double y = angleStick.getY();
    
        double angle = Math.toDegrees(Math.atan2(y, x));
    
        // Handle transition from 360 to 0 degrees
        if (angle < 0) {
          angle += 360;
        }
    
        return angle;
      }
    
      private double getSpeed() {
        return theDriveTrain.getSpeed();
      }
}
